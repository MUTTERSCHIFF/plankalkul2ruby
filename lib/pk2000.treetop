grammar Pk2000

   rule program 
      "P" number randauszug "\n" lines "\nEND" <PKMethodNode>
      / lines
   end

   rule randauszug
      vTuple "=>" rTuple
   end

   rule vTuple
      ("(V0[:" type "])" 
      / "(V0[:" type "],V1[:" type "])" 
      / "(V0[:" type "],V1[:" type "],V2[:" type "])") {
	 def toRuby
	    # only need comma-delimited list of var-names
	    text_value.gsub(/\(|\)|\[[^V]*\]/, "").downcase
	 end
      }
   end

   rule rTuple
      "(R0[:" type "])" <PKVariableNode>
      / "(R0[:" type "],R1[:" type "])" <PKVariableNode>
      / "(R0[:" type "],R1[:" type "],R2[:" type "])" <PKVariableNode>
   end

   rule lines
      first:statement rest:("\n" next:lines)? <PKIterativeNode>
   end

   rule statement
      assignment / ifThen / while / block / builtIns / term2 / "(" statement ")" 
   end
   
   rule assignment
      (from:term2 "=>" to:variable / from:tuple "=>" to:variable / from:tuple "=>" to:varTuple) {
         def toRuby
            to.toRuby+" <= "+from.toRuby
         end
      }
   end

   rule ifThen
      term2 "->" statement {
         def toRuby
            "if "+term2.toRuby+"\n"+statement.toRuby+"\nend"
         end
      }
   end

   rule while
      ("w" / "W") count:"1"? ("[" level:number "]")? fixed:("(" forTo:operation ")")? block <PKWhileNode>
   end

   rule block
      "[" lines "]" {
         def toRuby
            "{"+lines.toRuby+"}"
         end
      }
   end

   rule builtIns
      "FIN" number? <PKFinNode>
   end

   rule term2
      call / condition 
   end

   rule call
      "R" [0-9]+ "[" component? ":" type "](" term2 (comma term2)* ")" <PKCallNode>
   end

   rule count
      "N(" variable ")" {
	 def toRuby
	    variable.toRuby+".dimension"
	 end
      }
   end

   rule prefix
      ("-" / "!" &([A-Z0-9] / "(" / genericVariable))
   end

   rule term
      genericVariable / variable / constant / count 
   end 

   rule prefixedTerm
      prefix term / term / "(" term2 ")" 
   end


   rule tuple
      varTuple
      /
      "(" first:term2 rest:(comma next:term2)+ ")" <PKIterativeNode>
   end

   rule varTuple
      "(" first:variable rest:(comma next:variable)+ ")" <PKIterativeNode>
   end

   rule condition
      prefixedTerm op:("=" / "<" / ">") condition <PKOperationNode>
      / tuple "=" tuple
      / operation
   end

   rule operation
      prefixedTerm op:("+" / "-" / "*" / "/" / "&" / "|" / "~") condition <PKOperationNode>
      / prefixedTerm 
   end

   rule constant
      "0" / number / logConstant 
   end

   rule logConstant
      "+" logConstant* / "-" logConstant*
   end

   rule variable
      ("V" / "Z" / "R") [0-9]+ "[" component? ":" type "]" <PKVariableNode>
   end

   rule dot
      "." 
   end

   rule comma
      "," 
   end

   rule simpleType
      "0"
   end

   rule type
      simpleType / tupleType / number dot type
   end

   rule tupleType
      "(" first:type rest:(comma next:type)+ ")" <PKIterativeNode>
   end

   rule component
      [0-9]+ dot component / term2 / [0-9]+ / variable / genericVariable
   end

   rule genericVariable
      "i" number
      / "i"
   end

   rule number
      [1-9] [0-9]*
   end
end
